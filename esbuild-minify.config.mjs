import process from "process";
import builtins from 'builtin-modules';
import { sassPlugin } from 'esbuild-sass-plugin';
import { copy } from 'esbuild-plugin-copy';
import svg from 'esbuild-plugin-svg';
import esbuild from 'esbuild';
import fs from 'fs';
import path from 'path';
import { createRequire } from 'module';

// 创建alias插件来解决Tldraw库多次实例化问题
const aliasPlugin = (aliases) => ({
    name: 'alias',
    setup(build) {
        const require = createRequire(import.meta.url);
        
        // 为每个别名创建解析函数
        Object.keys(aliases).forEach(alias => {
            const target = aliases[alias];
            build.onResolve({ filter: new RegExp(`^${alias}$`) }, args => {
                return { path: require.resolve(target), external: false };
            });
        });
    }
});

// 定义输出目录，使用path.join来处理路径
const OUTPUT_DIR = path.join('D:/', 'My Note', '.obsidian', 'plugins', 'ink');

const renamePlugin = () => ({
	name: 'rename-plugin',
	setup(build) {
		build.onEnd(async () => {
			try {
				// 只有当文件存在时才尝试重命名
				if (fs.existsSync(path.join(OUTPUT_DIR, 'main.css'))) {
					fs.renameSync(path.join(OUTPUT_DIR, 'main.css'), path.join(OUTPUT_DIR, 'styles.css'));
				}
			} catch (e) {
				console.log('Info: No need to rename main.css to styles.css');
			}
		});
	}
});

const copyManifestPlugin = () => ({
	name: 'copy-manifest-plugin',
	setup(build) {
		build.onEnd(async () => {
			try {
				fs.copyFileSync('./manifest.json', path.join(OUTPUT_DIR, 'manifest.json'));
			} catch (e) {
				console.error('Failed to copy manifest.json to output directory:', e);
			}
			// 不再复制manifest-beta.json文件
		});
	}
});

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = (process.argv[2] === 'production');

// 确保自定义CSS有更高的优先级
const cssPriorityPlugin = () => ({
	name: 'css-priority-plugin',
	setup(build) {
		// 这个插件确保自定义CSS在构建时被正确处理
		// 优先级问题将通过更具体的选择器解决
	}
});

// 单行化插件 - 在构建后将main.js转换为单行格式
const singleLinePlugin = () => ({
	name: 'single-line-plugin',
	setup(build) {
		build.onEnd(async () => {
			try {
				const mainJsPath = path.join(OUTPUT_DIR, 'main.js');
				if (fs.existsSync(mainJsPath)) {
					// 读取文件内容
					let content = fs.readFileSync(mainJsPath, 'utf8');
					
					// 使用更安全的方法转换为单行，避免破坏正则表达式
					// 首先识别并保护所有字符串和正则表达式
					const protectedParts = [];
					
					// 保护正则表达式
					content = content.replace(/\/((?![*\/]).+?)(?<!\\)\/[gimuy]*/g, (match) => {
						const id = `__PROTECTED_${protectedParts.length}__`;
						protectedParts.push(match);
						return id;
					});
					
					// 保护单引号字符串
					content = content.replace(/'([^'\\]*(\\.[^'\\]*)*)'/g, (match) => {
						const id = `__PROTECTED_${protectedParts.length}__`;
						protectedParts.push(match);
						return id;
					});
					
					// 保护双引号字符串
					content = content.replace(/"([^"\\]*(\\.[^"\\]*)*)"/g, (match) => {
						const id = `__PROTECTED_${protectedParts.length}__`;
						protectedParts.push(match);
						return id;
					});
					
					// 保护模板字符串
					content = content.replace(/`([^`]*)`/g, (match) => {
						const id = `__PROTECTED_${protectedParts.length}__`;
						protectedParts.push(match);
						return id;
					});
					
					// 现在安全地移除换行符和多余空格
					content = content
						.replace(/\/\/.*$/gm, '') // 移除单行注释
						.replace(/\/\*[\s\S]*?\*\//g, '') // 移除多行注释
						.replace(/\n\s*/g, '') // 移除换行符和行首空格
						.replace(/\s{2,}/g, ' ') // 将多个连续空格替换为单个空格
						.replace(/([;{}])\s+/g, '$1') // 移除分号、大括号后的空格
						.replace(/\s+([;{}])/g, '$1') // 移除分号、大括号前的空格
						.trim();
					
					// 恢复所有被保护的部分
					protectedParts.forEach((part, i) => {
						content = content.replace(`__PROTECTED_${i}__`, part);
					});
					
					// 写回文件
					fs.writeFileSync(mainJsPath, content);
					console.log('Successfully converted main.js to single line format');
				}
			} catch (e) {
				console.error('Failed to convert main.js to single line format:', e);
			}
		});
	}
});

esbuild.build({
		banner: {
			js: banner
		},
		entryPoints: ['./src/main.ts'],
		bundle: true,
		external: [
			'obsidian',
			'electron',
			'@codemirror/autocomplete',
			'@codemirror/collab',
			'@codemirror/commands',
			'@codemirror/language',
			'@codemirror/lint',
			'@codemirror/search',
			'@codemirror/state',
			'@codemirror/view',
			'@lezer/common',
			'@lezer/highlight',
			'@lezer/lr',
			...builtins
		],
		// 配置模块解析，优先使用es模块格式来避免重复导入
		// 确保只使用一个版本的依赖库
		// 首先尝试ES模块格式，然后再尝试CommonJS格式
		mainFields: ['module', 'browser', 'main'],
		// 优先解析ES模块文件
		resolveExtensions: ['.ts', '.tsx', '.mjs', '.jsx', '.js', '.cjs', '.json'],
		// 确保所有tldraw相关模块都从node_modules解析，避免重复导入
		preserveSymlinks: true,
		format: 'cjs',
		watch: !prod,
		target: 'es2020',
		logLevel: 'info',
		sourcemap: false, // 禁用源码映射以获得更小的文件
		treeShaking: true,
		minify: true, // 启用所有压缩选项
		minifyWhitespace: true, // 压缩空白字符
		minifyIdentifiers: true, // 压缩标识符
		minifySyntax: true, // 压缩语法
		outdir: OUTPUT_DIR,
		loader: {
			// '.png': 'file',
			// '.woff2': 'file',
			// '.json': 'file',
			// '.png': 'dataurl',
			// '.woff2': 'dataurl',
			// '.json': 'dataurl'
		},
		// assetNames: "./assets/[name]",
		// 确保tsconfig.json中的模块解析配置正确
		tsconfig: 'tsconfig.json',
		plugins: [
			// 使用alias插件解决Tldraw库多次实例化问题
			aliasPlugin({
				'tldraw': './node_modules/tldraw',
				'@tldraw/editor': './node_modules/@tldraw/editor',
				'@tldraw/store': './node_modules/@tldraw/store',
				'@tldraw/state': './node_modules/@tldraw/state',
				'@tldraw/state-react': './node_modules/@tldraw/state-react',
				'@tldraw/tlschema': './node_modules/@tldraw/tlschema',
				'@tldraw/utils': './node_modules/@tldraw/utils',
				'@tldraw/validate': './node_modules/@tldraw/validate'
			}),
			// CSS优先级插件应该在sassPlugin之前运行
			cssPriorityPlugin(),
			sassPlugin({
				filter: /\.(s[ac]ss|css)$/
			}),
			svg(),
			copy({
				resolveFrom: 'cwd',	// 返回当前工作目录的名称
				assets: {
					from: ['./src/static/**/*'],
					to: [OUTPUT_DIR]
				}
			}),

			// 允许manifest.json存在于根目录，这是Obsidian在存储库中期望的，构建时会将其复制到dist
			copyManifestPlugin(),
			// 将main.css重命名为styles.css，因为这是obsidian期望的
			renamePlugin()
			// 移除了单行化插件，使用esbuild内置压缩
		],
		define: {
			'process.env.NODE_ENV': JSON.stringify(prod ? 'production' : 'development')
		}
}).catch(() => process.exit(1));